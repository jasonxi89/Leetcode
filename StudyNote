#This is a study note for what i already done
Medium597. 具有最大平均数的子树
中文English
给一棵二叉树，找到有最大平均值的子树。返回子树的根结点。

样例
给一个二叉树：

     1
   /   \
 -5     11
 / \   /  \
1   2 4    -2
返回节点 11。

注意事项
LintCode会打印出根结点为你返回节点的子树，保证有最大平均数子树只有一棵

声明个全局变量MAX？然后开始遍历？好像也不对，如何判断是不是该舍弃该值？比如说如果左节点是5，平均值是10，那左节点应该舍弃，难道要遍历一遍全部的组合么？
不对，题目要求是子树，那么说起来不是路径，可以考虑从头开始排着算？return返回count和sum,一个计算走了多少个Node，一个计算sum,self一个全局记录最大值

开始想说做个stack一个一个往外pop,但是最后事实发现根本不需要这种东西，直接返回SUM和数量就行，思路是对的，主要是出在遍历的问题上，还需要多联系





Medium 474. 最近公共祖先 II
中文English
给一棵二叉树和二叉树中的两个节点，找到这两个节点的最近公共祖先LCA。

两个节点的最近公共祖先，是指两个节点的所有父亲节点中（包括这两个节点），离这两个节点最近的公共的节点。

每个节点除了左右儿子指针以外，还包含一个父亲指针parent，指向自己的父亲。

样例
例1：

输入：
       4
      / \
     3  7
        / \
       5  6
和3,5
产量：4
说明：LCA（3,5）= 4

例2：

输入：
       4
      / \
     3  7
        / \
       5  6
和5,6
输出：7
说明：LCA（5,6）= 7


LCA问题，返回是不是找到A和B，好像天天做系列（LintCode578）
思路：直接递归，如果root是A或者是B或者是空，直接返回ROOT，然后递归左右，看看值是空还是什么，如果左右都不是空，那就意味着找到了当前值，直接返回ROOT






Hard 901. 二叉搜索树中最接近的值 II
中文English
给定一棵非空二叉搜索树以及一个target值，找到 BST 中最接近给定值的 k 个数。

样例
给出 root = {1}, target = 0.000000, k = 1, 返回 [1].

挑战
假设是一棵平衡二叉搜索树，你可以用时间复杂度低于O(n)的算法解决问题吗( n 为节点个数)？

注意事项
给出的target值为浮点数
你可以假设 k 总是合理的，即 k ≤ 总节点数
我们可以保证给出的 BST 中只有唯一一个最接近给定值的 k 个值的集合

思路：直接一个set,用pop法找最接近值？或者遍历排序？好像都挺笨的
https://www.jiuzhang.com/solution/closest-binary-search-tree-value-ii/#tag-highlight-lang-python
答案，完全没思路，有空整理下:
建议大家还是掌握这个时间复杂度O（k + lgn）的解法
要不然面试的评级肯定不会高，即使做出来 O（n）又有什么用呢
毕竟题目中出现k就是希望你能用它来减少时间复杂度的

方法如下：
首先建立两个数组 prev 和 next 用来储存比target小的node和比它大的node
再用while k:去遍历k个数，提前取出他们的值，比较大小，再调用方法 getNext 或 getPrev即可




Hard 86. 二叉查找树迭代器
设计实现一个带有下列属性的二叉查找树的迭代器：
next()返回BST中下一个最小的元素

元素按照递增的顺序被访问（比如中序遍历）
next()和hasNext()的询问操作要求均摊时间复杂度是O(1)
样例
对于下列二叉查找树，使用迭代器进行中序遍历的结果为 [1, 6, 10, 11, 12]

   10
 /    \
1      11
 \       \
  6       12
挑战
额外空间复杂度是O(h)，其中h是这棵树的高度

Super Star：使用O(1)的额外空间复杂度




easy246. 二叉树的路径和 II
中文English
给一棵二叉树和一个目标值，设计一个算法找到二叉树上的和为该目标值的所有路径。路径可以从任何节点出发和结束，但是需要是一条一直往下走的路线。也就是说，路径上的节点的层级是逐个递增的。

样例
对于二叉树：

    1
   / \
  2   3
 /   /
4   2
给定目标值6。那么满足条件的路径有两条：

[
  [2, 4],
  [1, 3, 2]
]

先序遍历，加path,然后不停往外pop




155. 二叉树的最小深度
中文English
给定一个二叉树，找出其最小深度。

二叉树的最小深度为根节点到最近叶子节点的距离。
样例
Example 1:
	Input: {}
	Output: 0


Example 2:
	Input:  {1,#,2,3}
	Output: 3

	Explanation:
	1
	 \
	  2
	 /
	3


Example 3:
	Input:  {1,2,3,#,#4,5}
	Output: 2

	Explanation:
      1
     / \
    2   3
       / \
      4   5

分治法，分成以下四种情况：

    1.当前节点有左右子树，分别计算左右子树的minimum depth，返回其中最小值 + 1
    2.当前节点只有左子树，返回左子树的minimum depth + 1
    3.当前节点只有右子树，返回右子树的minimum depth + 1
    4.当前节点没有左右子树（叶子节点），返回1
分析之后，可发现2，3，4可归纳成一条规律。总体的算法如下

    递归的出口：当前为None，返回0
    分别计算左右子树的minimum depth, 记为leftDepth 和 rightDepth
    若当前节点有左右子树，返回min(leftDepth, rightDepth) + 1, 否则返回max(leftDepth, rightDepth) + 1
