总结：

遍历控制全局变量，无需return值

分治法return 值：无脑先递归左右，然后开始处理问题(先把任务都给小弟，然后跟小弟说怎么做)
return的东西要足够判断问题

搜索二叉树：中序遍历递增


联系
分治法（Divide & Conquer）与遍历法（Traverse）是两种常见的递归（Recursion）方法。

分治法解决问题的思路
先让左右子树去解决同样的问题，然后得到结果之后，再整合为整棵树的结果。

遍历法解决问题的思路
通过前序/中序/后序的某种遍历，游走整棵树，通过一个全局变量或者传递的参数来记录这个过程中所遇到的点和需要计算的结果。

两种方法的区别
从程序实现角度分治法的递归函数，通常有一个返回值，遍历法通常没有。

全子集问题，四种方法，非递归的类的有
1.选择法(0表示选这个，1表示不选)
2.BFS（回溯，deque）

递归
回溯：核心思想是递归的时候传进个可以开始选的index,然后for循环下一个可以开始选的位置，for循环里用回溯（先subset.add,然后递归，然后subset.move最后一个加进去的）
例如 123，1的时候，先变成12，然后变成123(这个是For里的递归搞定)，然后把2去掉(subset.remove搞定)，变成1,然后再加3，变成13(for循环搞定)


什么时候用BFS：深度比较深，最短路径，分层遍历，拓谷排序，非递归找所有方案

什么时候用DFS：找所有方案

比较DFS/BFS:BFS的空间复杂度，取决于宽度；DFS的空间复杂度，取决于深度。

PS:背诵Binary Tree iterator.

看到视频41分钟
