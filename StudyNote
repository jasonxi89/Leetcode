#This is a study note for what i already done
Medium597. 具有最大平均数的子树
中文English
给一棵二叉树，找到有最大平均值的子树。返回子树的根结点。

样例
给一个二叉树：

     1
   /   \
 -5     11
 / \   /  \
1   2 4    -2
返回节点 11。

注意事项
LintCode会打印出根结点为你返回节点的子树，保证有最大平均数子树只有一棵

声明个全局变量MAX？然后开始遍历？好像也不对，如何判断是不是该舍弃该值？比如说如果左节点是5，平均值是10，那左节点应该舍弃，难道要遍历一遍全部的组合么？
不对，题目要求是子树，那么说起来不是路径，可以考虑从头开始排着算？return返回count和sum,一个计算走了多少个Node，一个计算sum,self一个全局记录最大值

开始想说做个stack一个一个往外pop,但是最后事实发现根本不需要这种东西，直接返回SUM和数量就行，思路是对的，主要是出在遍历的问题上，还需要多联系





Medium 474. 最近公共祖先 II
中文English
给一棵二叉树和二叉树中的两个节点，找到这两个节点的最近公共祖先LCA。

两个节点的最近公共祖先，是指两个节点的所有父亲节点中（包括这两个节点），离这两个节点最近的公共的节点。

每个节点除了左右儿子指针以外，还包含一个父亲指针parent，指向自己的父亲。

样例
例1：

输入：
       4
      / \
     3  7
        / \
       5  6
和3,5
产量：4
说明：LCA（3,5）= 4

例2：

输入：
       4
      / \
     3  7
        / \
       5  6
和5,6
输出：7
说明：LCA（5,6）= 7


LCA问题，返回是不是找到A和B，好像天天做系列（LintCode578）
思路：直接递归，如果root是A或者是B或者是空，直接返回ROOT，然后递归左右，看看值是空还是什么，如果左右都不是空，那就意味着找到了当前值，直接返回ROOT






Hard 901. 二叉搜索树中最接近的值 II
中文English
给定一棵非空二叉搜索树以及一个target值，找到 BST 中最接近给定值的 k 个数。

样例
给出 root = {1}, target = 0.000000, k = 1, 返回 [1].

挑战
假设是一棵平衡二叉搜索树，你可以用时间复杂度低于O(n)的算法解决问题吗( n 为节点个数)？

注意事项
给出的target值为浮点数
你可以假设 k 总是合理的，即 k ≤ 总节点数
我们可以保证给出的 BST 中只有唯一一个最接近给定值的 k 个值的集合

思路：直接一个set,用pop法找最接近值？或者遍历排序？好像都挺笨的
https://www.jiuzhang.com/solution/closest-binary-search-tree-value-ii/#tag-highlight-lang-python
答案，完全没思路，有空整理下:
建议大家还是掌握这个时间复杂度O（k + lgn）的解法
要不然面试的评级肯定不会高，即使做出来 O（n）又有什么用呢
毕竟题目中出现k就是希望你能用它来减少时间复杂度的

方法如下：
首先建立两个数组 prev 和 next 用来储存比target小的node和比它大的node
再用while k:去遍历k个数，提前取出他们的值，比较大小，再调用方法 getNext 或 getPrev即可




Hard 86. 二叉查找树迭代器
设计实现一个带有下列属性的二叉查找树的迭代器：
next()返回BST中下一个最小的元素

元素按照递增的顺序被访问（比如中序遍历）
next()和hasNext()的询问操作要求均摊时间复杂度是O(1)
样例
对于下列二叉查找树，使用迭代器进行中序遍历的结果为 [1, 6, 10, 11, 12]

   10
 /    \
1      11
 \       \
  6       12
挑战
额外空间复杂度是O(h)，其中h是这棵树的高度

Super Star：使用O(1)的额外空间复杂度
