#This is a study note for what i already done
Medium597. 具有最大平均数的子树
中文English
给一棵二叉树，找到有最大平均值的子树。返回子树的根结点。

样例
给一个二叉树：

     1
   /   \
 -5     11
 / \   /  \
1   2 4    -2
返回节点 11。

注意事项
LintCode会打印出根结点为你返回节点的子树，保证有最大平均数子树只有一棵

声明个全局变量MAX？然后开始遍历？好像也不对，如何判断是不是该舍弃该值？比如说如果左节点是5，平均值是10，那左节点应该舍弃，难道要遍历一遍全部的组合么？
不对，题目要求是子树，那么说起来不是路径，可以考虑从头开始排着算？return返回count和sum,一个计算走了多少个Node，一个计算sum,self一个全局记录最大值

开始想说做个stack一个一个往外pop,但是最后事实发现根本不需要这种东西，直接返回SUM和数量就行，思路是对的，主要是出在遍历的问题上，还需要多联系





Medium 474. 最近公共祖先 II
中文English
给一棵二叉树和二叉树中的两个节点，找到这两个节点的最近公共祖先LCA。

两个节点的最近公共祖先，是指两个节点的所有父亲节点中（包括这两个节点），离这两个节点最近的公共的节点。

每个节点除了左右儿子指针以外，还包含一个父亲指针parent，指向自己的父亲。

样例
例1：

输入：
       4
      / \
     3  7
        / \
       5  6
和3,5
产量：4
说明：LCA（3,5）= 4

例2：

输入：
       4
      / \
     3  7
        / \
       5  6
和5,6
输出：7
说明：LCA（5,6）= 7


LCA问题，返回是不是找到A和B，好像天天做系列（LintCode578）
思路：直接递归，如果root是A或者是B或者是空，直接返回ROOT，然后递归左右，看看值是空还是什么，如果左右都不是空，那就意味着找到了当前值，直接返回ROOT






Hard 901. 二叉搜索树中最接近的值 II
中文English
给定一棵非空二叉搜索树以及一个target值，找到 BST 中最接近给定值的 k 个数。

样例
给出 root = {1}, target = 0.000000, k = 1, 返回 [1].

挑战
假设是一棵平衡二叉搜索树，你可以用时间复杂度低于O(n)的算法解决问题吗( n 为节点个数)？

注意事项
给出的target值为浮点数
你可以假设 k 总是合理的，即 k ≤ 总节点数
我们可以保证给出的 BST 中只有唯一一个最接近给定值的 k 个值的集合

思路：直接一个set,用pop法找最接近值？或者遍历排序？好像都挺笨的
https://www.jiuzhang.com/solution/closest-binary-search-tree-value-ii/#tag-highlight-lang-python
答案，完全没思路，有空整理下:
建议大家还是掌握这个时间复杂度O（k + lgn）的解法
要不然面试的评级肯定不会高，即使做出来 O（n）又有什么用呢
毕竟题目中出现k就是希望你能用它来减少时间复杂度的

方法如下：
首先建立两个数组 prev 和 next 用来储存比target小的node和比它大的node
再用while k:去遍历k个数，提前取出他们的值，比较大小，再调用方法 getNext 或 getPrev即可




Hard 86. 二叉查找树迭代器
设计实现一个带有下列属性的二叉查找树的迭代器：
next()返回BST中下一个最小的元素

元素按照递增的顺序被访问（比如中序遍历）
next()和hasNext()的询问操作要求均摊时间复杂度是O(1)
样例
对于下列二叉查找树，使用迭代器进行中序遍历的结果为 [1, 6, 10, 11, 12]

   10
 /    \
1      11
 \       \
  6       12
挑战
额外空间复杂度是O(h)，其中h是这棵树的高度

Super Star：使用O(1)的额外空间复杂度




easy246. 二叉树的路径和 II
中文English
给一棵二叉树和一个目标值，设计一个算法找到二叉树上的和为该目标值的所有路径。路径可以从任何节点出发和结束，但是需要是一条一直往下走的路线。也就是说，路径上的节点的层级是逐个递增的。

样例
对于二叉树：

    1
   / \
  2   3
 /   /
4   2
给定目标值6。那么满足条件的路径有两条：

[
  [2, 4],
  [1, 3, 2]
]

先序遍历，加path,然后不停往外pop




155. 二叉树的最小深度
中文English
给定一个二叉树，找出其最小深度。

二叉树的最小深度为根节点到最近叶子节点的距离。
样例
Example 1:
	Input: {}
	Output: 0


Example 2:
	Input:  {1,#,2,3}
	Output: 3

	Explanation:
	1
	 \
	  2
	 /
	3


Example 3:
	Input:  {1,2,3,#,#4,5}
	Output: 2

	Explanation:
      1
     / \
    2   3
       / \
      4   5

分治法，分成以下四种情况：

    1.当前节点有左右子树，分别计算左右子树的minimum depth，返回其中最小值 + 1
    2.当前节点只有左子树，返回左子树的minimum depth + 1
    3.当前节点只有右子树，返回右子树的minimum depth + 1
    4.当前节点没有左右子树（叶子节点），返回1
分析之后，可发现2，3，4可归纳成一条规律。总体的算法如下

    递归的出口：当前为None，返回0
    分别计算左右子树的minimum depth, 记为leftDepth 和 rightDepth
    若当前节点有左右子树，返回min(leftDepth, rightDepth) + 1, 否则返回max(leftDepth, rightDepth) + 1




easy 68. 二叉树的后序遍历
中文English
给出一棵二叉树，返回其节点值的后序遍历。

样例
给出一棵二叉树 {1,#,2,3},

   1
    \
     2
    /
   3
返回 [3,2,1]

挑战
你能使用非递归实现么？
无脑加？不用递归就遍历就BFS，然后反过来玩

easy 67. 二叉树的中序遍历
中文English
给出一棵二叉树,返回其中序遍历

样例
给出二叉树 {1,#,2,3},

   1
    \
     2
    /
   3
返回 [1,3,2].

挑战
你能使用非递归算法来实现么?

递归:left print right
非递归 queen
https://www.jianshu.com/p/456af5480cee
三种遍历方法的考查顺序一致，得到的结果却不一样，原因在于：
先序：考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树。(根左右)
中序：考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。(左根右)
后序：考察到一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。(左右根)

需要的改动仅仅调换一下节点访问的次序，先序是先访问，再入栈；
而中序则是先入栈，弹栈后再访问




Medium 915. BST的中序前驱节点
中文English
给出一棵二叉搜索树以及其中的一个节点，找到这个节点在这棵树中的中序前驱节点。

样例
给出 root = {2,1,3}, p = 1, 返回 null.

注意事项
如果给出的节点在树中没有中序前驱节点， 返回 null。

#思路，中序是左根右，所以当相等的时候，找到最后一个值就好





Medium 448. 二叉查找树的中序后继
中文English
给定一个二叉查找树(什么是二叉查找树)，以及一个节点，求该节点在中序遍历的后继，如果没有返回null

样例
给出 tree = [2,1] node = 1:

  2
 /
1
返回 node 2.

给出 tree = [2,1,3] node = 2:

  2
 / \
1   3
返回 node 3.

挑战
O(h)，其中h是BST的高度。

注意事项
保证p是给定二叉树中的一个节点。(您可以直接通过内存地址找到p)

中序：左中右，二次查找，找下一个？还是直接返回？好像不能直接返回，如果是最右边的话，POP的下一个，并不一定是要找的值，递归简单好像

好的我是个傻逼！！！这是个二叉搜索树！！！搜索！！！树！！！

用successor维护前一位，左子树如果一直比p值大则一直向左找，一旦左节点值大于p则p一定在右子树上




Medium 88. 最近公共祖先
中文English
给定一棵二叉树，找到两个节点的最近公共父节点(LCA)。

最近公共祖先是两个节点的公共的祖先节点且具有最大深度。

样例
对于下面这棵二叉树

  4
 / \
3   7
   / \
  5   6
LCA(3, 5) = 4

LCA(5, 6) = 7

LCA(6, 7) = 7

注意事项
假设给出的两个节点都在树中存在

思路：后续，直接开搞




easy 595. 二叉树最长连续序列
中文English
给一棵二叉树，找到最长连续路径的长度。
这条路径是指 任何的节点序列中的起始节点到树中的任一节点都必须遵循 父-子 联系。最长的连续路径必须是从父亲节点到孩子节点（不能逆序）。

样例
例1:

输入:
   1
    \
     3
    / \
   2   4
        \
         5
输出:3
解释:
Longest consecutive sequence path is 3-4-5, so return 3.
例2:

输入:
   2
    \
     3
    /
   2
  /
 1
输出:2
解释:
Longest consecutive sequence path is 2-3,not 3-2-1, so return 2.

不知道为什么。。。1345不是= =！
